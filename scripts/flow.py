#!/usr/bin/env python3
"""
flow.py orchestrates the execution of all flows
"""

import argparse
import logging
import shutil
import subprocess
import sys
import yaml

from copy import deepcopy
from jinja2 import Template
from pathlib import Path

dry_run = False
assume_yes = False

logger = None

loggers = {
    'flow' : None,
    'bhsim' : None,
    'bitst' : None,
    'synth' : None,
    'pssim' : None,
    'prpwr' : None,
    'plink' : None,
    'fpga_flow' : None,
    'power_flow' : None
}

bhsim_template = Template("""
# =============================================================================
# bhsim.tcl | Auto-generated by flow.py
# =============================================================================

set adam "{{adam}}"
set synth "{{synth}}"

# Create Library
# =============================================================================
vlib lib/
vmap work lib/

# Technology Setup
# =============================================================================
set CMOS28FDSOI_PATH $env(CMOS28FDSOI_PATH)
vlog -work work $CMOS28FDSOI_PATH/C28SOI_SC_12_CORE_LL/5.1-05/behaviour/verilog/C28SOI_SC_12_CORE_LL.v

# Load Synthesized Design
# =============================================================================
vlog -work work $synth/synth.v

# Include Directories
# =============================================================================
set include [list \\
{%- for dir in include %}
  "$adam/{{dir}}" \\
{%- endfor %}
]

# Define Directives
# =============================================================================
set define [list \\
{%- for item in define %}
  "{{item}}" \\
{%- endfor %}
]

# Sources Files
# =============================================================================
set sources [list \\
{%- for file in sources %}
  "$adam/{{file}}" \\
{%- endfor %}
]

# Load Behavioral Files
# =============================================================================
set load_cmd "vlog -sv -work work "
foreach dir $include {
  append load_cmd "+incdir+$dir "
}
foreach def $define {
  append load_cmd "-define $def "
}
foreach file $sources {
  append load_cmd "$file "
}
eval $load_cmd

# Simulation
# =============================================================================
# Invoke simulation
vsim -t ns -suppress 3009 work.{{top}}

# Setup VCD
vcd file bhsim.vcd
vcd add -r /*

# Run simulation
while {1} {
  run 1ms
  vcd flush
  lassign [runStatus -full] status fullstat
  if {$fullstat != "end"} {
    break
  }
}

# Show performance-related statistics
echo [simstats]

# Exit
# =============================================================================
exit

""")

bitst_template = Template("""
# =============================================================================
# bitst.tcl | Auto-generated by flow.py
# =============================================================================

set adam "{{adam}}"

# Create Vivado project =======================================================

create_project adam ./adam -part "{{part}}"

# Add source files ============================================================

# Create 'sources_1' fileset (if not found)
if {[string equal [get_filesets -quiet sources_1] ""]} {
  create_fileset -srcset sources_1
}

set sources_1 [get_filesets sources_1]

add_files -norecurse -fileset $sources_1 [list \\
{%- for file in sources %}
  "$adam/{{file}}" \\
{%- endfor %}
]

set_property top "{{top}}" $sources_1

# Add constraint files ======================================================= #

# Create 'constrs_1' fileset (if not found)
if {[string equal [get_filesets -quiet constrs_1] ""]} {
  create_fileset -constrset constrs_1
}

# Get 'constrs_1' file set
set constrs_1 [get_filesets constrs_1]

# Add files to 'constrs_1' file set
add_files -norecurse -fileset $constrs_1 [list \\
{%- for file in constrs %}
  "$adam/{{file}}" \\
{%- endfor %}
]

# Add include dirs ============================================================

set include [list \\
{%- for dir in include %}
  "$adam/{{dir}}" \\
{%- endfor %}
]

set_property include_dirs $include $sources_1

# Add defines =================================================================

set_property verilog_define "{{ define | join(' ') }}" $sources_1

# Generate bitstream ==========================================================

launch_runs impl_1 -to_step write_bitstream -jobs 8
wait_on_run impl_1

file copy \\
  "./adam/adam.runs/impl_1/{{top}}.bit" \\
  "bitst.bit"

""")

synth_template = Template("""
# =============================================================================
# synth.tcl | Auto-generated by flow.py
# =============================================================================

set adam "{{adam}}"

# Technology Setup
# =============================================================================
set CMOS28FDSOI_PATH $env(CMOS28FDSOI_PATH)
set SNPS_SYN_PATH $env(SNPS_SYN_PATH)
set search_path	". \\
    $SNPS_SYN_PATH/libraries/syn \\
    $SNPS_SYN_PATH/dw/sim_ver \\
    $CMOS28FDSOI_PATH/C28SOI_SC_12_CORE_LL/5.1-05/libs "
set target_library "C28SOI_SC_12_CORE_LL_tt28_0.90V_0.00V_0.00V_0.00V_125C.db"
# set symbol_library "C28SOI_SC_12_CORE_LL.sdb"
# set synthetic_library dw_foundation.sldb 
set link_library "* $target_library "

# Include Directories
# =============================================================================
{%- for dir in include %}
lappend search_path "$adam/{{dir}}"
{%- endfor %}

# Define Directives
# =============================================================================
set define [list \\
{%- for item in define %}
  "{{item}}" \\
{%- endfor %}
]

# Source Files
# =============================================================================
set sources [list \\
{%- for file in sources %}
  "$adam/{{file}}" \\
{%- endfor %}
]

# Load Source Files
# =============================================================================
define_design_lib WORK -path lib/
set load_cmd "analyze -library WORK -format sverilog "
foreach def $define {
  append load_cmd "-define $def "
}
append load_cmd "\\$sources"
eval $load_cmd

# Elaboration
# =============================================================================
elaborate {{top}}
current_design {{top}}

# Synthesis Settings
# =============================================================================
# Avoid 'assign' statements in output netlist
set verilogout_no_tri true                

# Prefix for unconnected nets
set verilogout_unconnected_prefix "UNCONNECTED"  

# Keep vectored ports intact
set verilogout_single_bit false           

# Define clock settings
create_clock -name "clk" -period 20 -waveform { 10 20 }  { clk }

# Area optimization directive
set_max_area 0                            

# Uncomment if input/output and wire load constraints are needed
# =============================================================================
#set_clock_latency 0.3 clk_i
#set_input_delay 2.0 -clock clk_i [all_inputs]
#set_output_delay 1.65 -clock clk_i [all_inputs]
#set_load 0.1 [all_outputs]
#set_max_fanout 1 [all_inputs]
#set_fanout_load 8 [all_outputs]
#set auto_wire_load_selection true

# Compile and Save the Design
# =============================================================================
compile
write -format verilog -hierarchy -out synth.v {{top}}  
write -format ddc -hierarchy -output synth.ddc
report_area -hierarchy > area_report.txt

# Register List
# =============================================================================
set fp [open registers.txt w]
foreach_in_collection reg [all_registers] {puts $fp [get_object_name $reg]}
close $fp

# Troubleshooting and Exit
# =============================================================================
# Useful for troubleshooting
check_design
# change_names
# link

# Exit design compiler
exit   

""")

def bhsim(*args, **kargs):
    target = kargs['target']
    fsets = kargs['fsets']
    adam_path = kargs['adam_path']
    bhsim_path = kargs['bhsim_path']
    synth_path = kargs['synth_path']
    clean = kargs.get('clean', True)
    top = kargs.get('top', None)

    logger.info('Starting bhsim.')

    if clean:
        safe_rm(bhsim_path)
        bhsim_path.mkdir(parents=True)

    target = compile_target('bhsim', target)

    tcl_data = {}

    tcl_data['adam'] = adam_path
    tcl_data['synth'] = synth_path
    tcl_data['top'] = top if top else target['top']

    incs, srcs = compile_fset(target['fset'], fsets)

    tcl_data['include'] = clean_path_list(incs, adam_path)
    tcl_data['sources'] = clean_path_list(srcs, adam_path)

    tcl_path = bhsim_path / 'bhsim.tcl'
    tcl_raw = bhsim_template.render(**tcl_data)
    
    with open(tcl_path, 'w') as file:
        file.write(tcl_raw)

    exec_cmd(['vsim', '-c', '-do', f'source {tcl_path}'],
        bhsim_path, loggers['bhsim'])

def bitst(*args, **kargs):
    target = kargs['target']
    fsets = kargs['fsets']
    adam_path = kargs['adam_path']
    bitst_path = kargs['bitst_path']
    clean = kargs.get('clean', True)

    logger.info('Starting bitst.')

    if clean:
        safe_rm(bitst_path)
        bitst_path.mkdir(parents=True)

    target = compile_target('bitst', target)

    tcl_data = {}

    tcl_data['adam'] = Path(adam_path).resolve()
    tcl_data['part'] = target['part'] 
    tcl_data['top'] = target['top']

    incs, srcs = compile_fset(target['fset'], fsets)
    cons = [target['xdc']]

    tcl_data['include'] = clean_path_list(incs, adam_path)
    tcl_data['sources'] = clean_path_list(srcs, adam_path)
    tcl_data['constrs'] = clean_path_list(cons, adam_path)
    
    define = target['define']
    define = define if define else []
    tcl_data['define'] = define

    tcl_path = bitst_path / 'bitst.tcl'
    tcl_raw = bitst_template.render(**tcl_data)
    
    with open(tcl_path, 'w') as file:
        file.write(tcl_raw)

    exec_cmd(['vivado', '-mode', 'batch', '-source', tcl_path],
        bitst_path, loggers['bitst'])


def synth(*args, **kargs):
    target = kargs['target']
    fsets = kargs['fsets']
    adam_path = kargs['adam_path']
    synth_path = kargs['synth_path']
    clean = kargs.get('clean', True)

    logger.info('Starting synth.')

    if clean:
        safe_rm(synth_path)
        synth_path.mkdir(parents=True)

    target = compile_target('synth', target)

    tcl_data = {}

    tcl_data['adam'] = Path(adam_path).resolve()
    tcl_data['top'] = target['top']

    incs, srcs = compile_fset(target['fset'], fsets)

    tcl_data['include'] = clean_path_list(incs, adam_path)
    tcl_data['sources'] = clean_path_list(srcs, adam_path)

    tcl_path = synth_path / 'synth.tcl'
    tcl_raw = synth_template.render(**tcl_data)

    with open(tcl_path, 'w') as f:
        f.write(tcl_raw)

    exec_cmd(['dc_shell', '-f', tcl_path],
        synth_path, loggers['synth']) 


def exec_cmd(cmd, work_path, logger):
    if dry_run:
        return

    if not shutil.which(cmd[0]):
        raise RuntimeError(f'shell: "{cmd[0]}" not found.')

    process = subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE, 
        stderr=subprocess.STDOUT, 
        cwd=work_path.resolve()
    )

    pipe = process.stdout
    for line in iter(pipe.readline, b''):
        logger.info(line.decode().strip())
    process.terminate()

    return process.returncode


def setup_log(log_path):
    global logger
    global loggers

    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)

    formatter = logging.Formatter('%(asctime)s %(tag)-5s | %(message)s',
        "%Y-%m-%d %H:%M:%S")

    stdout_handler = logging.StreamHandler(sys.stdout)
    stdout_handler.setFormatter(formatter)
    root_logger.addHandler(stdout_handler)

    file_handler = logging.FileHandler(log_path, mode='a')
    file_handler.setFormatter(formatter)    
    root_logger.addHandler(file_handler)

    for key in loggers:
        loggers[key] = logging.LoggerAdapter(root_logger,
            extra={'tag':key.upper()})

    logger = loggers['flow']


def safe_rm(path):
    if path.exists():

        if assume_yes:
            answer = 'y'
        else:
            msg = f'{path} exists. Overwrite? (y/n): '
            answer = input(msg).lower()

        if answer == 'y':
            logger.warning(f'Overwriting {path}')

            if path.is_dir():
                shutil.rmtree(path)
            else:
                path.unlink()
        else:
            raise RuntimeError('Abort.')


def compile_fset(fset_name, fsets, solved=None):
    incs = []
    srcs = []

    if solved is None:
        solved = []

    if fset_name not in fsets:
        raise RuntimeError(f'compile_fset: "{fset_name}" does not exist.')

    fset = fsets[fset_name]
    for req in fset.get('requires', []):
        if req not in solved:
            x, y = compile_fset(req, fsets, solved=solved)
            incs += x
            srcs += y
        
    root = Path(fset.get('root', '.'))
    incs += [root/inc for inc in fset.get('includes', [])]
    srcs += [root/src for src in fset.get('sources', [])]

    solved += [fset_name]

    return incs, srcs

def compile_target(command_name, target):
    res = deepcopy(target)
    if command_name in target.get('override', {}):
        recursive_update(res, target['override'][command_name])
    return res

def clean_path_list(path_list, anchor):
    return [Path(path).resolve().relative_to(anchor) for path in path_list]

def recursive_update(d, u):
    for k, v in u.items():
        if isinstance(v, dict):
            d[k] = recursive_update(d.get(k, {}), v)
        else:
            d[k] = v
    return d

def list_as_none(d):
    for key, value in d.items():
        if value is None:
            d[key] = []
        elif isinstance(value, dict):
            list_as_none(value)
    return d

def main():
    global dry_run
    global assume_yes
    global logger
    global loggers

    parser = argparse.ArgumentParser(
        description='Orchestrates the execution of all flows.')

    parser.add_argument('-p', '--project', type=Path,
        help='The ADAM path.')
    parser.add_argument('-w', '--work', type=Path,
        help='The work path.') 
    parser.add_argument('-t', '--target', type=str,
        help='The ADAM target.')                        
    parser.add_argument('-d', '--dry-run', action='store_true',
        help='Perform a dry run (only generate scripts).')
    parser.add_argument('-y', '--assume-yes', action='store_true',
        help='Assume "yes" for all prompts.')

    # Add subparsers for the subcommands
    subparsers = parser.add_subparsers(
        title='command',
        dest='command'
    )

    # Define the 'bhsim' command
    bhsim_parser = subparsers.add_parser('bhsim',
        description='Perform behavioral simulation using ModelSim.',
        help='Behavioral Simulation')
    bhsim_parser.add_argument('--top', type=str,
        help='top module')

    # Define the 'bitst' command
    bitst_parser = subparsers.add_parser('bitst',
        description='Perform bitstream generation using Vivado',
        help='Bitstream')

    # Define the 'synth' command
    synth_parser = subparsers.add_parser('synth',
        description='Perform synthesis using Design Compiler.',
        help='Synthesis')
    
    # Define the 'pssim' command
    pssim_parser = subparsers.add_parser('pssim',
        description='Executes the simulation step using ModelSim.',
        help='Post-synthesis Simulation')

    # Define the 'prpwr' command
    prpwr_parser = subparsers.add_parser('prpwr',
        description='Executes PowerPrime.',
        help='PrimePower')

    # Define the 'plink' command
    plink_parser = subparsers.add_parser('plink',
        description='Executes power_linker.py',
        help='power_linker.py')

    # Define the 'fpga_flow' command
    fpga_flow_parser = subparsers.add_parser('fpga_flow',
        description='Executes all commands for FPGA bitstream generation.',
        help='FPGA Flow')

    # Define the 'power_flow' command
    power_flow_parser = subparsers.add_parser('power_flow',
        description='Executes all commands for Power Analysis.',
        help='Power Analysis Flow')
    power_flow_parser.add_argument('--fifo', action='store_true',
        help='use FIFO for intermediary files when supported')

    args = parser.parse_args()

    adam_path = args.project
    if not adam_path:
        adam_path = Path(__file__).parent.parent.resolve()

    work_path = args.work
    if not work_path:
        work_path = adam_path / 'work'
    work_path.mkdir(parents=True, exist_ok=True)

    adam_yaml_path = adam_path / 'adam.yml'
    with open(adam_yaml_path, 'r') as f:
        adam_yaml = list_as_none(yaml.safe_load(f))

    target_name = args.target
    command = args.command

    dry_run = args.dry_run
    assume_yes = args.assume_yes

    targets = adam_yaml['targets']
    if not targets:
        raise RuntimeError('No targets.')
    if not target_name:
        target_name = list(targets.keys())[0]
    target = targets[target_name]

    target_path = work_path / target_name
    target_path.mkdir(parents=True, exist_ok=True)
    
    bhsim_path = target_path / 'bhsim'
    bitst_path = target_path / 'bitst'
    synth_path = target_path / 'synth'
    pssim_path = target_path / 'pssim'
    prpwr_path = target_path / 'prpwr'
    plink_path = target_path / 'plink'

    log_path = target_path / 'flow.log'

    fsets = adam_yaml['fsets']

    setup_log(log_path)

    logger.info('Flow started.')

    common_kargs = {
        'target_name' : target_name,
        'target' : target,
        'fsets' : fsets,
        'adam_path' : adam_path,
        'bhsim_path' : bhsim_path,
        'bitst_path' : bitst_path,
        'synth_path' : synth_path,
        'pssim_path' : pssim_path,
        'prpwr_path' : prpwr_path,
        'plink_path' : plink_path
    }

    if command == 'bhsim':
        raise RuntimeError('Not yet implemented')
    elif command == 'bitst':
        bitst(**common_kargs)
    elif command == 'synth':
        raise RuntimeError('Not yet implemented')
    elif command == 'prpwr':
        raise RuntimeError('Not yet implemented')
    elif command == 'plink':
        raise RuntimeError('Not yet implemented')
    elif command == 'fpga_flow':
        raise RuntimeError('Not yet implemented')
    elif command == 'power_flow':
        raise RuntimeError('Not yet implemented')
    else:
        print("Invalid command.")
        parser.print_help()
        exit(-1)

if __name__ == '__main__':
    main()