#!/usr/bin/env python3
"""
adam.py orchestrates the execution of all flows
"""

import argparse
import logging
import shutil
import subprocess
import sys
import yaml

from copy import deepcopy
from jinja2 import Template
from pathlib import Path

dry_run = False
assume_yes = False
gui = False
dirty = False

logger = None

loggers = {
    'flow' : None,
    'atgen' : None,
    'vunit' : None,
    'bitst' : None,
    'synth' : None,
    'pssim' : None,
    'prpwr' : None,
    'plink' : None
}

vunit_template = Template("""
# =============================================================================
# run.py | Auto-generated by adam.py
# =============================================================================

from pathlib import Path
from vunit import VUnit

adam = Path("{{adam}}")

# Include Directories
# =============================================================================
includes = [
{%- for include in includes %}
    adam / "{{include}}",
{%- endfor %}
]

# Define Directives
# =============================================================================
defines = {
{%- for k, v in defines.items() %}
    "{{k}}" : "{{v}}",
{%- endfor %}
}

# Source Files
# =============================================================================
sources = [
{%- for source in sources %}
    adam / "{{source}}",
{%- endfor %}
]

# Run VUnit
# =============================================================================
VU = VUnit.from_argv()
VU.add_verilog_builtins()
VU.add_library("lib")

sources = [str(src) for src in sources]
includes = [str(inc) for inc in includes]

for source in sources:
    VU.add_source_file(
        file_name=source,
        library_name="lib",
        include_dirs=includes,
        defines=defines
    )

VU.main()

""")

bitst_template = Template("""
# =============================================================================
# bitst.tcl | Auto-generated by adam.py
# =============================================================================

set adam "{{adam}}"

# Create Vivado project =======================================================

create_project adam ./adam -part "{{part}}"

# Add source files ============================================================

# Create 'sources_1' fileset (if not found)
if {[string equal [get_filesets -quiet sources_1] ""]} {
  create_fileset -srcset sources_1
}

set sources_1 [get_filesets sources_1]

add_files -norecurse -fileset $sources_1 [list \\
{%- for file in sources %}
  "$adam/{{file}}" \\
{%- endfor %}
]

set_property top "{{top}}" $sources_1

# Add constraint files ========================================================

# Create 'constrs_1' fileset (if not found)
if {[string equal [get_filesets -quiet constrs_1] ""]} {
  create_fileset -constrset constrs_1
}

# Get 'constrs_1' file set
set constrs_1 [get_filesets constrs_1]

# Add files to 'constrs_1' file set
add_files -norecurse -fileset $constrs_1 [list \\
{%- for file in constrs %}
  "$adam/{{file}}" \\
{%- endfor %}
]

# Add include dirs ============================================================

set includes [list \\
{%- for include in includes %}
  "$adam/{{include}}" \\
{%- endfor %}
]

set_property include_dirs $includes $sources_1

# Add defines =================================================================

set_property verilog_define "{{ defines | join(' ') }}" $sources_1

# Generate bitstream ==========================================================

set nproc [exec nproc]

launch_runs impl_1 -to_step write_bitstream -jobs 32
wait_on_run impl_1

file copy \\
  "./adam/adam.runs/impl_1/{{top}}.bit" \\
  "bitst.bit"

""")

synth_template = Template("""
# =============================================================================
# synth.tcl | Auto-generated by adam.py
# =============================================================================

set adam "{{adam}}"

# Technology Setup
# =============================================================================
set CMOS28FDSOI_PATH $env(CMOS28FDSOI_PATH)
set SNPS_SYN_PATH $env(SNPS_SYN_PATH)
set search_path	". \\
    $SNPS_SYN_PATH/libraries/syn \\
    $SNPS_SYN_PATH/dw/sim_ver \\
    $CMOS28FDSOI_PATH/C28SOI_SC_12_CORE_LL/5.1-05/libs "
set target_library "C28SOI_SC_12_CORE_LL_tt28_0.90V_0.00V_0.00V_0.00V_125C.db"
# set symbol_library "C28SOI_SC_12_CORE_LL.sdb"
# set synthetic_library dw_foundation.sldb 
set link_library "* $target_library "

# Include Directories
# =============================================================================
{%- for include in includes %}
lappend search_path "$adam/{{include}}"
{%- endfor %}

# Define Directives
# =============================================================================
set defines [list \\
{%- for item in defines %}
  "{{item}}" \\
{%- endfor %}
]

# Source Files
# =============================================================================
set sources [list \\
{%- for file in sources %}
  "$adam/{{file}}" \\
{%- endfor %}
]

# Load Source Files
# =============================================================================
define_design_lib WORK -path lib/
set load_cmd "analyze -library WORK -format sverilog "
foreach define $defines {
  append load_cmd "-define $define "
}
append load_cmd "\\$sources"
eval $load_cmd

# Elaboration
# =============================================================================
elaborate {{top}}
current_design {{top}}

# Synthesis Settings
# =============================================================================
# Avoid 'assign' statements in output netlist
set verilogout_no_tri true                

# Prefix for unconnected nets
set verilogout_unconnected_prefix "UNCONNECTED"  

# Keep vectored ports intact
set verilogout_single_bit false           

# Define clock settings
create_clock -name "clk" -period 20 -waveform { 10 20 }  { clk }

# Area optimization directive
set_max_area 0                            

# Uncomment if input/output and wire load constraints are needed
# =============================================================================
#set_clock_latency 0.3 clk_i
#set_input_delay 2.0 -clock clk_i [all_inputs]
#set_output_delay 1.65 -clock clk_i [all_inputs]
#set_load 0.1 [all_outputs]
#set_max_fanout 1 [all_inputs]
#set_fanout_load 8 [all_outputs]
#set auto_wire_load_selection true

# Compile and Save the Design
# =============================================================================
compile
write -format verilog -hierarchy -out synth.v {{top}}  
write -format ddc -hierarchy -output synth.ddc
report_area -hierarchy > area_report.txt

# Register List
# =============================================================================
set fp [open registers.txt w]
foreach_in_collection reg [all_registers] {puts $fp [get_object_name $reg]}
close $fp

# Troubleshooting and Exit
# =============================================================================
# Useful for troubleshooting
check_design
# change_names
# link

# Exit design compiler
exit   

""")

def atgen(*args, **kargs):
    target_name = kargs['target_name']
    target = kargs['target']
    default = kargs['default']
    adam_path = kargs['adam_path']
    atgen_path = kargs['atgen_path']
    clean = kargs.get('clean', True)

    logger.info('Starting atgen.')

    if clean and not dirty:
        safe_rm(atgen_path)
    
    atgen_path.mkdir(parents=True, exist_ok=True)

    target = compile_target(target, default)

    gen_pkg_path = adam_path / 'scripts' / 'gen_pkg.py'
    gen_ral_path = adam_path / 'scripts' / 'gen_ral.py'
    
    yml_path = atgen_path / 'target.yml'
    pkg_path = atgen_path / 'adam_cfg_pkg.sv'
    ral_path = adam_path/ 'software' / 'hal' / 'inc' / 'adam_ral.h'

    with open(yml_path, 'w') as file:
        yaml.dump(target, file)

    cmd = ['python', gen_pkg_path, yml_path, '-o', pkg_path, '-t', target_name]
    exec_cmd(cmd, atgen_path, loggers['atgen'])

    cmd = ['python', gen_ral_path, yml_path, '-o', ral_path, '-t', target_name]
    exec_cmd(cmd, atgen_path, loggers['atgen'])

def vunit(*args, **kargs):
    target = kargs['target']
    default = kargs['default']
    fsets = kargs['fsets']
    adam_path = kargs['adam_path']
    atgen_path = kargs['atgen_path']
    vunit_path = kargs['vunit_path']
    clean = kargs.get('clean', True)

    logger.info('Starting vunit.')

    if clean and not dirty:
        safe_rm(vunit_path)
    
    vunit_path.mkdir(parents=True, exist_ok=True)

    target = compile_target(target, default)
    top = kargs.get('top')

    py_data = {}

    py_data['adam'] = adam_path
    
    incs, srcs = compile_fsets(target['bhv_fsets'], fsets)

    adam_cfg_pkg_path = (atgen_path / 'adam_cfg_pkg.sv').relative_to(adam_path)
    srcs = [adam_cfg_pkg_path] + srcs

    py_data['includes'] = incs
    py_data['sources'] = srcs

    defines = {}
    for define in target.get('defines', []):
        k, v, *_ = define.strip().split("=") + ['']
        defines[k] = v
    py_data['defines'] = defines

    py_path = vunit_path / 'run.py'
    py_raw = vunit_template.render(**py_data)
    
    with open(py_path, 'w') as file:
        file.write(py_raw)

    cmd = ['python', py_path, '-o', vunit_path]
    cmd += ['-g'] if gui else []
    
    if top:
        cmd += [f'lib.{top}' if '.' in top else f'lib.{top}.*']
 
    exec_cmd(cmd, vunit_path, loggers['vunit'])

def bitst(*args, **kargs):
    target = kargs['target']
    default = kargs['default']
    fsets = kargs['fsets']
    adam_path = kargs['adam_path']
    atgen_path = kargs['atgen_path']
    bitst_path = kargs['bitst_path']
    clean = kargs.get('clean', True)

    logger.info('Starting bitst.')

    if clean and not dirty:
        safe_rm(bitst_path)
    
    bitst_path.mkdir(parents=True, exist_ok=True)

    target = compile_target(target, default)

    tcl_data = {}

    tcl_data['adam'] = Path(adam_path).resolve()
    tcl_data['part'] = target['part'] 
    tcl_data['top'] = target['top']

    incs, srcs = compile_fsets(target['rtl_fsets'], fsets)
    cons = [target['xdc']]

    adam_cfg_pkg_path = (atgen_path / 'adam_cfg_pkg.sv').relative_to(adam_path)
    srcs = [adam_cfg_pkg_path] + srcs

    tcl_data['includes'] = incs
    tcl_data['sources'] = srcs
    tcl_data['constrs'] = cons
    
    defines = target.get('defines', [])
    tcl_data['defines'] = defines

    tcl_path = bitst_path / 'bitst.tcl'
    tcl_raw = bitst_template.render(**tcl_data)
    
    with open(tcl_path, 'w') as file:
        file.write(tcl_raw)

    exec_cmd(['vivado', '-mode', 'batch', '-source', tcl_path],
        bitst_path, loggers['bitst'])


def synth(*args, **kargs):
    target = kargs['target']
    default = kargs['default']
    fsets = kargs['fsets']
    adam_path = kargs['adam_path']
    atgen_path = kargs['atgen_path']
    synth_path = kargs['synth_path']
    clean = kargs.get('clean', True)

    logger.info('Starting synth.')

    if clean and not dirty:
        safe_rm(synth_path)
    
    synth_path.mkdir(parents=True, exist_ok=True)

    target = compile_target(target, default)

    tcl_data = {}

    tcl_data['adam'] = Path(adam_path).resolve()
    tcl_data['top'] = target['top']

    incs, srcs = compile_fsets(target['rtl_fsets'], fsets)

    adam_cfg_pkg_path = (atgen_path / 'adam_cfg_pkg.sv').relative_to(adam_path)
    srcs = [adam_cfg_pkg_path] + srcs

    tcl_data['includes'] = incs
    tcl_data['sources'] = srcs

    tcl_path = synth_path / 'synth.tcl'
    tcl_raw = synth_template.render(**tcl_data)

    with open(tcl_path, 'w') as f:
        f.write(tcl_raw)

    exec_cmd(['dc_shell', '-f', tcl_path],
        synth_path, loggers['synth']) 


def test_flow(*args, **kargs):
    atgen_path = kargs['atgen_path']
    vunit_path = kargs['vunit_path']
    clean = kargs.get('clean', True)

    if clean and not dirty:
        safe_rm(atgen_path)
        safe_rm(vunit_path)
    
    atgen(*args, **kargs)
    vunit(*args, **kargs)

def fpga_flow(*args, **kargs):
    atgen_path = kargs['atgen_path']
    bitst_path = kargs['bitst_path']
    clean = kargs.get('clean', True)

    if clean and not dirty:
        safe_rm(atgen_path)
        safe_rm(bitst_path)
    
    atgen(*args, **kargs)
    bitst(*args, **kargs)

def exec_cmd(cmd, work_path, logger):
    if dry_run:
        return

    if not shutil.which(cmd[0]):
        raise RuntimeError(f'shell: "{cmd[0]}" not found.')

    process = subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE, 
        stderr=subprocess.STDOUT, 
        cwd=work_path.resolve(),
        encoding='utf8'
    )

    pipe = process.stdout
    for line in iter(pipe.readline, ''):
        logger.info(line.strip())
    process.terminate()
    return process.returncode


def setup_log(log_path):
    global logger
    global loggers

    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)

    formatter = logging.Formatter('%(asctime)s %(tag)-5s | %(message)s',
        "%Y-%m-%d %H:%M:%S")

    stdout_handler = logging.StreamHandler(sys.stdout)
    stdout_handler.setFormatter(formatter)
    root_logger.addHandler(stdout_handler)

    file_handler = logging.FileHandler(log_path, mode='a')
    file_handler.setFormatter(formatter)    
    root_logger.addHandler(file_handler)

    for key in loggers:
        loggers[key] = logging.LoggerAdapter(root_logger,
            extra={'tag':key.upper()})

    logger = loggers['flow']


def safe_rm(path):
    if path.exists():

        if assume_yes:
            answer = 'y'
        else:
            msg = f'{path} exists. Overwrite? (y/n): '
            answer = input(msg).lower()

        if answer == 'y':
            logger.warning(f'Overwriting {path}')

            if path.is_dir():
                shutil.rmtree(path)
            else:
                path.unlink()
        else:
            raise RuntimeError('Abort.')

def compile_fsets(fset_names, fsets):
    incs = []
    srcs = []

    for name in fset_names:
        part_incs, part_srcs = compile_fset(name, fsets)
        incs += part_incs
        srcs += part_srcs

    return incs, srcs

def compile_fset(fset_name, fsets, solved=None):
    incs = []
    srcs = []

    if solved is None:
        solved = []

    if fset_name not in fsets:
        raise RuntimeError(f'compile_fset: "{fset_name}" does not exist.')

    fset = fsets[fset_name]
    for req in fset.get('requires', []):
        if req not in solved:
            x, y = compile_fset(req, fsets, solved=solved)
            incs += x
            srcs += y
        
    root = Path(fset.get('root', '.'))
    incs += [root/inc for inc in fset.get('includes', [])]
    srcs += [root/src for src in fset.get('sources', [])]

    solved += [fset_name]

    return incs, srcs

def compile_target(target, default):
    res = deepcopy(default)
    recursive_update(res, target)
    return res

def recursive_update(d, u):
    for k, v in u.items():
        if isinstance(v, dict):
            d[k] = recursive_update(d.get(k, {}), v)
        else:
            d[k] = v
    return d

def list_as_none(d):
    for key, value in d.items():
        if value is None:
            d[key] = []
        elif isinstance(value, dict):
            list_as_none(value)
    return d

def main():
    global dry_run
    global assume_yes
    global gui
    global dirty
    global logger
    global loggers

    parser = argparse.ArgumentParser(
        description='Orchestrates the execution of all flows.')

    parser.add_argument('-p', '--project', type=Path,
        help='The ADAM path.')
    parser.add_argument('-w', '--work', type=Path,
        help='The work path.') 
    parser.add_argument('-t', '--target', type=str,
        help='The ADAM target.')                        
    parser.add_argument('-d', '--dry-run', action='store_true',
        help='Perform a dry run (only generate scripts).')
    parser.add_argument('-y', '--assume-yes', action='store_true',
        help='Assume "yes" for all prompts.')
    parser.add_argument('-g', '--gui', action='store_true',
        help='Open GUIs. (when supported)')
    parser.add_argument('--dirty', action='store_true',
        help='Does not clean work directories.')

    # Add subparsers for the subcommands
    subparsers = parser.add_subparsers(
        title='command',
        dest='command'
    )

    # Define the 'atgen' command
    atgen_parser = subparsers.add_parser('atgen',
        description='Generates automatically generated code',
        help='Code generators')

    # Define the 'vunit' command
    vunit_parser = subparsers.add_parser('vunit',
        description='Perform VUnit tests.',
        help='VUnit')
    vunit_parser.add_argument('--top', type=str,
        help='Top module')

    # Define the 'bitst' command
    bitst_parser = subparsers.add_parser('bitst',
        description='Perform bitstream generation using Vivado.',
        help='Bitstream')

    # Define the 'synth' command
    synth_parser = subparsers.add_parser('synth',
        description='Perform synthesis using Design Compiler.',
        help='Synthesis')
    
    # Define the 'pssim' command
    pssim_parser = subparsers.add_parser('pssim',
        description='Executes the simulation step using ModelSim.',
        help='Post-synthesis Simulation')

    # Define the 'prpwr' command
    prpwr_parser = subparsers.add_parser('prpwr',
        description='Executes PowerPrime.',
        help='PrimePower')

    # Define the 'plink' command
    plink_parser = subparsers.add_parser('plink',
        description='Executes power_linker.py',
        help='power_linker.py')

    # Define the 'test_flow' command
    test_flow_parser = subparsers.add_parser('test_flow',
        description='Executes all commands for design verification.',
        help='Test Flow')
    test_flow_parser.add_argument('--top', type=str,
        help='Top module')

    # Define the 'fpga_flow' command
    fpga_flow_parser = subparsers.add_parser('fpga_flow',
        description='Executes all commands for FPGA bitstream generation.',
        help='FPGA Flow')

    # Define the 'power_flow' command
    power_flow_parser = subparsers.add_parser('power_flow',
        description='Executes all commands for Power Analysis.',
        help='Power Analysis Flow')
    power_flow_parser.add_argument('--fifo', action='store_true',
        help='use FIFO for intermediary files when supported')

    args = parser.parse_args()

    adam_path = args.project
    if not adam_path:
        adam_path = Path(__file__).parent.parent.resolve()

    work_path = args.work
    if not work_path:
        work_path = adam_path / 'work'
    work_path.mkdir(parents=True, exist_ok=True)

    adam_yaml_path = adam_path / 'adam.yml'
    with open(adam_yaml_path, 'r') as f:
        adam_yaml = list_as_none(yaml.safe_load(f))

    target_name = args.target
    command = args.command

    dry_run = args.dry_run
    assume_yes = args.assume_yes
    gui = args.gui
    dirty = args.dirty

    targets = adam_yaml['targets']
    default = adam_yaml['default']

    if not targets:
        raise RuntimeError('No targets.')
    if not target_name:
        target_name = 'default'

    if target_name == 'default':
        target = default
    else:
        target = targets[target_name]

    target_path = work_path / target_name
    target_path.mkdir(parents=True, exist_ok=True)
    
    atgen_path = target_path / 'atgen'
    vunit_path = target_path / 'vunit'
    bitst_path = target_path / 'bitst'
    synth_path = target_path / 'synth'
    pssim_path = target_path / 'pssim'
    prpwr_path = target_path / 'prpwr'
    plink_path = target_path / 'plink'

    log_path = target_path / 'flow.log'

    fsets = adam_yaml['fsets']

    setup_log(log_path)

    logger.info('Hello.')

    common_kargs = {
        'target_name' : target_name,
        'target' : target,
        'default' : default,
        'fsets' : fsets,
        'adam_path' : adam_path,
        'atgen_path' : atgen_path,
        'vunit_path' : vunit_path,
        'bitst_path' : bitst_path,
        'synth_path' : synth_path,
        'pssim_path' : pssim_path,
        'prpwr_path' : prpwr_path,
        'plink_path' : plink_path
    }

    if command == 'atgen':
        atgen(**common_kargs)
    elif command == 'vunit':
        vunit(**common_kargs, top=args.top)
    elif command == 'bitst':
        bitst(**common_kargs)
    elif command == 'synth':
        raise RuntimeError('Not yet implemented')
    elif command == 'prpwr':
        raise RuntimeError('Not yet implemented')
    elif command == 'plink':
        raise RuntimeError('Not yet implemented')
    elif command == 'test_flow':
        test_flow(**common_kargs, top=args.top)
    elif command == 'fpga_flow':
        fpga_flow(**common_kargs)
    elif command == 'power_flow':
        raise RuntimeError('Not yet implemented')
    else:
        print("Invalid command.")
        parser.print_help()
        exit(-1)

if __name__ == '__main__':
    main()